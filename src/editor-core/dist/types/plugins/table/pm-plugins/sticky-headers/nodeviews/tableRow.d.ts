import { Node as PmNode } from 'prosemirror-model';
import { EditorView, NodeView } from 'prosemirror-view';
import { EventDispatcher } from '../../../../../event-dispatcher';
import { TablePluginState } from '../../../types';
import { TableDOMElements } from './dom';
export declare const supportedHeaderRow: (node: PmNode) => boolean;
export declare class TableRowNodeView implements NodeView {
    view: EditorView;
    node: PmNode;
    getPos: () => number;
    eventDispatcher: EventDispatcher;
    dom: HTMLTableRowElement;
    contentDOM: HTMLElement;
    isHeaderRow: boolean;
    scrollElement?: HTMLElement | Window;
    colControlsOffset: number;
    focused: boolean;
    scrollElementTop: number;
    isSticky: boolean;
    constructor(node: PmNode, view: EditorView, getPos: any, eventDispatcher: EventDispatcher);
    listening: boolean;
    subscribe(): void;
    unsubscribe(): void;
    previousDomTop: number | undefined;
    previousPadding: number | undefined;
    latestDomTop: number | undefined;
    nextFrame: number | undefined;
    onScroll: () => void;
    loop: () => void;
    paint: (tree: TableDOMElements) => void;
    update(node: PmNode, ...args: any[]): boolean;
    destroy(): void;
    ignoreMutation(mutationRecord: MutationRecord | {
        type: 'selection';
        target: Element;
    }): boolean;
    onTablePluginState: (state: TablePluginState) => void;
    onWidthPluginState: () => void;
    shouldHeaderStick: (tree: TableDOMElements) => boolean;
    makeHeaderRowSticky: (tree: TableDOMElements) => void;
    getWrapperoffset: (inverse?: boolean) => number;
    getWrapperRefTop: (wrapper: HTMLElement) => number;
    getScrolledTableTop: (wrapper: HTMLElement) => number;
    getCurrentTableTop: (tree: TableDOMElements) => number;
    makeRowHeaderNotSticky: (table: HTMLElement) => void;
    padding: number;
    top: number;
    emitOn: (top: number, padding: number) => void;
    emitOff: () => void;
}
